/***************************************************************
 * 文件名 : bsp_delay.c
 * 功能   : 系统毫秒延时 + 系统时基（用于超时机制）
 * 说明   : 
 *   1. 使用 SysTick 产生 1ms 中断
 *   2. 全局变量 g_ms_tick 记录系统运行毫秒数
 *   3. BSP_Delay_ms 基于 g_ms_tick 实现非阻塞延时
 *   4. 微秒级延时可单独实现，不干扰系统时基
 ***************************************************************/

#include "stm32f10x.h"
#include "bsp_delay.h"

/*-----------------------------------------------------------
 * 全局变量：系统毫秒计数
 * 由 SysTick 中断每 1ms 自增一次
 *----------------------------------------------------------*/
volatile uint32_t g_ms_tick = 0;

/*-----------------------------------------------------------
 * SysTick 中断服务函数
 * 每 1ms 触发一次，累加系统运行毫秒数
 *----------------------------------------------------------*/
void SysTick_Handler(void)
{
    g_ms_tick++;
}

/*-----------------------------------------------------------
 * 函数名 : BSP_TimeBase_Init
 * 功能   : 初始化系统时基，配置 SysTick 1ms 中断
 * 调用时机: 系统启动阶段（main 最开始调用一次即可）
 * 注意   :
 *   1. SysTick_Config 内部已经开启中断，不需要额外设置
 *   2. 初始化后 g_ms_tick 开始递增，可用于延时和超时
 *----------------------------------------------------------*/
void BSP_TimeBase_Init(void)
{
    // SystemCoreClock / 1000 => 每 1ms 产生一次中断
    SysTick_Config(SystemCoreClock / 1000);
}

/*-----------------------------------------------------------
 * 函数名 : BSP_GetTick
 * 功能   : 获取系统当前运行时间（毫秒）
 * 返回值 : 系统运行毫秒数
 * 用途   : 超时检测、非阻塞延时、协议状态机
 *----------------------------------------------------------*/
uint32_t BSP_GetTick(void)
{
    return g_ms_tick;
}

/*-----------------------------------------------------------
 * 函数名 : BSP_Delay_ms
 * 功能   : 延时指定毫秒数（基于系统时基）
 * 参数   : ms - 延时毫秒数
 * 注意   :
 *   1. 非阻塞系统时基的实现，不影响 SysTick
 *   2. CPU 会忙等，延时期间可响应中断
 *   3. 精度受 SysTick 中断周期影响（1ms）
 *----------------------------------------------------------*/
void BSP_Delay_ms(uint32_t ms)
{
    uint32_t start = BSP_GetTick();
    while( (BSP_GetTick() - start) < ms );
}

/*-----------------------------------------------------------
 * 可选微秒延时函数（短精度）
 * 注意：
 *   1. 只用于 GPIO 精确脉冲或复位等短延时
 *   2. 不能破坏系统时基，不要再反复配置 SysTick
 *   3. 如果需要更高精度可使用 DWT CYCCNT 实现
 *----------------------------------------------------------*/
void BSP_Delay_us(uint32_t us)
{
    // 下面是简单忙等方法，仅用于短延时 (<1ms)
    // 不开中断，不破坏系统时基
    uint32_t count = us * (SystemCoreClock / 1000000); // 系统时钟周期换算
    while(count--) __NOP();
}

/*-----------------------------------------------------------
 * 可选秒延时
 *----------------------------------------------------------*/
void BSP_Delay_s(uint32_t s)
{
    while(s--) {
        BSP_Delay_ms(1000);
    }
}
